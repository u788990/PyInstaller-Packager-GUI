- name: Build with PyInstaller Direct
      run: |
        Write-Host "Bypassing wrapper script, running PyInstaller directly..."
        
        # 1. 构建基础命令
        # --clean: 清理缓存
        # -y: 覆盖输出目录
        $cmd = 'pyinstaller "${{ inputs.source_file }}" --name "${{ inputs.output_name }}" --clean -y'
        
        # 2. 设置打包模式 (onedir / onefile)
        if ("${{ inputs.pack_mode }}" -eq "onedir") {
            $cmd += " --onedir"
        } else {
            $cmd += " --onefile"
        }
        
        # 3. 设置是否隐藏控制台
        if ("${{ inputs.no_console }}" -eq "true") {
            $cmd += " --noconsole"
        }
        
        # 4. 【关键修复】强制收集 AI 依赖库
        # 这就是之前报错的原因，现在直接传给 pyinstaller 就不会报错了
        $cmd += " --collect-all rembg --collect-all onnxruntime --hidden-import onnxruntime --hidden-import rembg"
        
        # 5. 设置图标 (只设置主图标，防止格式不兼容)
        $exeIcon = "${{ inputs.exe_icon }}".Trim()
        if ($exeIcon -ne "" -and (Test-Path $exeIcon)) {
            # PyInstaller 在 Windows 上最好使用 .ico，如果是 .png 可能会有警告但通常也能用
            $cmd += " --icon `"$exeIcon`""
        }
        
        # 6. 打印最终命令以便调试
        Write-Host "=========================================="
        Write-Host "Executing Command:"
        Write-Host $cmd
        Write-Host "=========================================="
        
        # 7. 执行命令
        Invoke-Expression $cmd
        
        # 8. 错误检查
        if ($LASTEXITCODE -ne 0) {
            Write-Host "Build failed with exit code: $LASTEXITCODE"
            exit $LASTEXITCODE
        }
      shell: pwsh
